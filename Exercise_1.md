<p align="center">
<font size = 12> Описание контейнерного инструмента Grafana </font>
</p>

---------

## Что такое Grafana 
Grafana - программное обеспечение, позволяющее запрашивать и визуализировать показатели (метрики), изучать и анализировать полученную информацию, настраивать и получать оповещения. 

Grafana позволяет подключать источники данных, такие как:
* базы данных временных рядов (TSDB);
* базы данных NoSQL / SQL;
* инструменты для оформления заявок (тикетов), такие как Jira или ServiceNow;
* инструменты CI / CD, такие как GitLab;
* и др.

Разберем, что такое:
+ контейнеры и для чего они нужны;
+ оркестратор Kubernetes и как он связан с контейнерами;
+ Prometheus и как он связан с Kubernetes;
+ Grafana и примеры применения.
  
## Немного истории
  1. Эра традиционного развертывания <br>
Раньше, когда бизнес и онлайн только начинали развиваться, приложения запускали на физических, железных серверах и не было возможности разграничивать их ёмкость (одно приложение могло использовать гораздо больше ресурсов чем другие приложения и мешать их работе). Решение проблемы – запускать каждое приложение на отдельном сервере. Но это не масштабируемо и поддержка множества серверов – дорого. 

  2. Эра виртуального развертывания <br>
Для решения задач масштабирования и более рационального расходования ресурсов была создана технология виртуальных серверов – запуск нескольких виртуальных машин на одном физическом сервере. Таким образом ресурсы сервера разделяются на части, приложение стали изолированы друг от друга, что обеспечило более высокий уровень безопасности, поскольку информация одного приложения перестала быть доступна другим приложениям. Арендовать виртуальный сервер проще и дешевле чем покупать свой собственный физический. В больших компаниях заметно сократились расходы на инфраструктуру. 

3. Эра контейнерного развертывания <br>
У системы виртуальных серверов есть недостаток – на виртуальной машине запускается ядро операционной системы и для каждого приложения запускать свою операционную систему довольно дорого. Это привело к созданию технологии контейнеров.

## Контейнеризация
**Контейнер** – это обособленное окружение со всем необходимым для запуска приложения в любой операционной системе. Контейнеры так же, как и виртуальные машины позволяют запускать каждое приложение изолированно друг от друга, но в отличие от виртуальных машин, они не запускают операционную систему под каждое приложение.

Подобно виртуальной машине контейнер имеет свою собственную файловую систему, процессор, память, пространство процессов и многое другое. Поскольку они не связаны с базовой инфраструктурой они переносимы между облаками и дистрибутивами операционных систем.

 Дополнительные преимущества контейнеров:
* создание и использование контейнера проще, чем виртуального сервера;
* создание контейнеров приложений не только во процессе развертывания, но и во время сборки/релиза;
* получение информации и метрик не только на уровне операционной системы, но также информации работоспособности самих приложений;
* окружающая среда на ноутбуке такая же, как и в облаке на всех этапах;
* совместимость облачных и операционных систем (работает в любых средах);
* приложение разбито на мелкие независимые части - микросервисы, которыми можно отдельно управлять;
* предсказуемая производительность приложения из-за изоляции ресурсов.

Технология контейнеризации связывает и запускает приложения. Но существует необходимость управления контейнерами и исключение ситуаций простоя: при выходе контейнера из строя - запуск другого контейнера. Для этих задач существует инструмент - оркестратор контейнеров **Kubernetes**.

## Kubernetes
Kubernetes масштабирует процессы, предоставляет шаблоны развёртывания, обрабатывает ошибки в приложениях и многое другое. Его работа напоминает работу дирижера в оркестре – отсюда и условное название – оркестратор.

Kubernetes позволяет:
* находить контейнеры по их уникальным номерам - IP адресам;
* распределять траффик при высокой нагрузке;
* автоматически разворачивать новые контейнеры при нехватке ресурсов/высокой нагрузке, и удалять лишние при восстановлении траффика;
* автоматически монтировать систему хранения - локальное хранилище, облака и другое;
* изменять фактическое состояние развернутых контейнеров;
* эффективно использовать указанные пользователем ресурсы - ЦП и память; 
* перезапускать отказавшие контейнеры;
* хранить и управлять конфиденциальной информацией, такой как пароли, токены и ключи.
  
Несмотря на широкий функционал Kubernetes, очень важно контролировать работу серверов, контейнеров, приложений, потребление ресурсов и другие процессы в системе.

## Prometheus
**Prometheus** – это целая система программ мониторинга, она собирает данные о работоспособности информационных систем, таких как Kubernetes, и позволяет проводить анализ этих данных.
 
Prometheus берёт нужную информацию с серверов и устройств, считывает параметры целевых объектов с установленными интервалами, передает на сервер и хранит эти данные в базе данных временных рядов

Работа с Prometheus не обойдётся без дополнения **Grafana** – с его помощью можно визуализировать полученные Prometheus данные в виде наглядных графиков, диаграмм и таблиц – дашбордов (dashboard).

## Grafana
Grafana — приложение для визуализации и аналитики информационных систем. 

Grafana позволяет:
+ визуализировать процессы и данные;
+ вести онлайн мониторинг;
+ собирать статистику;
+ проводить анализ данных. 

Основная функция Grafana — создания аналитических панелей - дашбордов. Данные для дашбордов берутся из подключённых источников: базы данных, рекламных кабинетов, облачных сервисов и других источников данных. 

Grafana в сочетании с Prometheus образуют двухстороннюю систему мониторинга. Grafana использует временные ряды и текстовые данные Prometheus и представляет их в графическом виде.

Особенности Grafana:
* создание информационной панели на основе данных;
* поддержка разных источников: бд, сервисы, кабинеты, api и др.;
* настройка уведомлений на изменение данных на панелях;
* публикация дашборда для внутреннего пользования или открытого;
* подключение плагинов из других облачных сервисов;
* различные типы визуализации данных.

Выводить на экран можно панели с графиками, диаграммами, различного вида шкалами, таблицы, данные карт и другие визуальные элементы. 

В Grafana можно создавать множество различных панелей:
* временные ряды;
* история состояния;
* столбчатая диаграмма;
* гисторамма;
* круговая диаграмма;
* датчик;
* и множество других.

## Развертывание Grafana на Kubernetes

### Пространство имен (namespace) в Kubernetes
Для лучшего управления ресурсами и исключения конфликтов и другим ошибок рекомендуется создать новое пространство имен (namespace) в Kubernetes

1. Чтобы создать ``namespace``, выполните следующую команду:
   ~~~ Bash
   kubectl create namespace my-grafana
   ~~~
   В данном примере название ``namespace`` ``my-grafana``
   <br>

2. Чтобы проверить и посмотреть созданный ``namespace``, выполните следующую команду:
   ~~~ Bash
   kubectl get namespace my-grafana
   ~~~

3. Создайте YAML-файл манифеста ``grafana.yaml``. Этот файл будет содержать необходимый код для развертывания.
   ~~~ Bash
   touch grafana.yaml
   ~~~

Далее нужно определить следующие объекты в ``grafana.yaml``:
 * Persistent Volume Claim (PVC) - хранилище данных;
 * Service - предоставляет сетевой доступ к модулю (Pod), определенному при развертывании;
 * Deployment - отвечает за создание модулей (Pods), обеспечение их актуальности, а также за управление набором реплики (Replicaset) и текущими обновлениями.

4. Скопируйте, вставьте и сохраните следующее содержимое в ``grafana.yaml``:
   
   ~~~ yaml
   ---
   apiVersion: v1
   kind: PersistentVolumeClaim
   metadata:
     name: grafana-pvc
   spec:
     accessModes:
       - ReadWriteOnce
     resources:
       requests:
         storage: 1Gi
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     labels:
       app: grafana
     name: grafana
   spec:
     selector:
       matchLabels:
         app: grafana
     template:
       metadata:
         labels:
           app: grafana
       spec:
         securityContext:
           fsGroup: 472
           supplementalGroups:
             - 0
         containers:
           - name: grafana
             image: grafana/grafana:latest
             imagePullPolicy: IfNotPresent
             ports:
               - containerPort: 3000
                 name: http-grafana
                 protocol: TCP
             readinessProbe:
               failureThreshold: 3
               httpGet:
                 path: /robots.txt
                 port: 3000
                 scheme: HTTP
               initialDelaySeconds: 10
               periodSeconds: 30
               successThreshold: 1
               timeoutSeconds: 2
             livenessProbe:
               failureThreshold: 3
               initialDelaySeconds: 30
               periodSeconds: 10
               successThreshold: 1
               tcpSocket:
                 port: 3000
               timeoutSeconds: 1
             resources:
               requests:
                 cpu: 250m
                 memory: 750Mi
             volumeMounts:
               - mountPath: /var/lib/grafana
                 name: grafana-pv
         volumes:
           - name: grafana-pv
             persistentVolumeClaim:
               claimName: grafana-pvc
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: grafana
   spec:
     ports:
       - port: 3000
         protocol: TCP
         targetPort: http-grafana
     selector:
       app: grafana
     sessionAffinity: None
     type: LoadBalancer
   ~~~

3. Выполните следующую команду, чтобы отправить манифест на сервер API Kubernetes:
   ~~~ Bash
   kubectl apply -f grafana.yaml --namespace=my-grafana
   ~~~
   Эта команда создает объекты PVC, Service и Deployment.
   <br>
3. Выполните следующие шаги, чтобы проверить состояние развертывания каждого объекта:
   
   a. Для получения PVC выполните следующую команду:
     ~~~ Bash
     kubectl get pvc --namespace=my-grafana -o wide
     ~~~


   b. Для развертывания выполните следующую команду:
     ~~~ Bash
     kubectl get deployments --namespace=my-grafana -o wide
     ~~~

   c. Для обслуживания выполните следующую команду:
     ~~~ Bash
     kubectl get svc --namespace=my-grafana -o wide
     ~~~

### Доступ к пользовательскому интерфейсу Grafana через веб-браузер с помощью minikube
1. Выполните следующую команду, чтобы получить IP-адрес службы Grafana:
   ~~~ Bash
   minikube service grafana --namespace=my-grafana
   ~~~
   
   Выведенная информация предоставит URL ссылку в виде IP-порта (адреса).

   ~~~ Bash
   |------------|---------|-------------|------------------------------|
   | NAMESPACE  |  NAME   | TARGET PORT |             URL              |
   |------------|---------|-------------|------------------------------|
   | my-grafana | grafana |        3000 | http://192.168.122.144:32182 |
   |------------|---------|-------------|------------------------------|
   Opening service my-grafana/grafana in default browser...
   http://192.168.122.144:32182
   ~~~

2. Для выполнения входа выполните команду ``curl``:
   ~~~ Bash
   curl 192.168.122.144:32182
   ~~~

2. Используйте полученный IP-порт (адрес) для доступа к пользовательскому интерфейсу Grafana через веб-браузер (введите в адресную строку полученный IP-порт). 

2. Для входа в учетную запись, используйте ``admin`` в поле логина и поле пароля.

### Обновление существующего развертывания, используя стратегию непрерывного обновления

Непрерывное обновление позволяет выполнять обновление развертывания без простоев за счет постепенного обновления модулей (Pods) новыми.

1. Чтобы просмотреть текущее состояние развертывания, выполните следующую команду:

   ~~~ Bash
   kubectl rollout history deployment/grafana --namespace=my-grafana
   ~~~

   Результат будет выглядеть примерно так:
   ~~~ Bash
   deployment.apps/grafana
   REVISION  CHANGE-CAUSE
   1         NONE
   ~~~
   Данная информация показывает, что после применения файла ``grafana.yaml`` ничего не обновлялось и не менялось.
<br>

2. Чтобы добавить данные для ведения учета первоначального развертывания, выполните следующую команду:

   ~~~ Bash
   kubectl annotate deployment/grafana kubernetes.io/change-cause='deployed the default base yaml file' --namespace=my-grafana
   ~~~

3. Чтобы просмотреть историю развертывания и проверить изменения, выполните следующую команду:
   ~~~ Bash
   kubectl rollout history deployment/grafana --namespace=my-grafana
   ~~~
   На экране отобразится обновленная информация, добавленная в ``CHANGE-CAUSE`` ранее.

### Изменение версии образа Grafana
1. Чтобы изменить развернутую версию Grafana, выполните команду ``kubectl edit``:
   ~~~ Bash
   kubectl edit deployment grafana --namespace=my-grafana
   ~~~

2. В редакторе измените образ контейнера в разделе ``kind: Deployment``

   строку:
   ~~~ Bash
   yaml image: grafana/grafana-oss:10.0.1
   ~~~

   на строку:
   ~~~ Bash
   yaml image: grafana/grafana-oss-dev:10.1.0-124419pre
   ~~~

3. Сохраните изменения
   после сохранения файла появится сообщение:
   ~~~ Bash
   deployment.apps/grafana edited
   ~~~
   Это значит, что изменения были применены.

4. Чтобы убедиться, что развертывание в кластере прошло успешно, выполните следующую команду:
   ~~~ Bash
   kubectl rollout status deployment grafana --namespace=my-grafana
   ~~~
   Успешное развертывание означает, что кластер Grafana теперь доступен.

5. Чтобы проверить состояние всех развернутых объектов, выполните следующую команду и добавьте ключ (дополнительная приписка к стандартной команде) ``-o wide`` для получения более подробных данных:
   ~~~ Bash
   kubectl get all --namespace=my-grafana -o wide
   ~~~
   Появится недавно развернутый образ ``grafana-oss-dev``.

6. Чтобы проверить это, войдите в пользовательский интерфейс Grafana в браузере, используя указанный IP порт из раздела выше.

   Откроется страница входа в Grafana.

7. Чтобы войти в Grafana, введите ``admin`` в строке имя пользователя и строке пароль.

8. В правом верхнем углу щелкните значок справки.

   Появится информация о версии.

9. Добавьте ``change cause`` данные для отслеживания действий с помощью команд:
   ~~~ Bash
   kubectl annotate deployment grafana --namespace=my-grafana kubernetes.io/change-cause='using grafana-oss-dev:10.1.0-124419pre for testing'
   ~~~

10. Для проверки выполните команду ``kubectl rollout history``:
      ~~~ Bash
      kubectl rollout history deployment grafana --namespace=my-grafana
      ~~~

      Появится:
      ~~~ Bash
      deployment.apps/grafana
      REVISION  CHANGE-CAUSE
      1         deploying the default yaml
      2         using grafana-oss-dev:10.1.0-124419pre for testing
      ~~~
      Это означает, что ``REVISION#2`` является текущей версией.
   Последняя строка вывода команды ``kubectl rollout history deployment`` - это версия, которая в данный момент активна и выполняется в текущей среде Kubernetes.

### Откат развертывания
Когда развертывание Grafana становится нестабильным из-за аварийного цикла, ошибок и т.д., можно откатить развертывание до более ранней версии (``REVISION``).

По умолчанию история развертывания Kubernetes сохраняется в системе, так что выполнить откат можно в любое время.

1. Для вывода всех версий ``REVISION``, выполните следующую команду:
   ~~~ Bash
   kubectl rollout history deployment grafana --namespace=my-grafana
   ~~~

2. Чтобы выполнить откат к предыдущей версии, выполните команду ``kubectl rollout undo`` и укажите номер ``REVISION``:

   ~~~ Bash
   kubectl rollout undo deployment grafana --to-revision=1 --namespace=my-grafana
   ~~~

3. Чтобы убедиться, что откат в кластере прошел успешно, выполните следующую команду:

   ~~~ Bash
   kubectl rollout status deployment grafana --namespace=my-grafana
   ~~~

4. Получите доступ к пользовательскому интерфейсу Grafana в браузере, используя указанный IP порт из раздела выше.

   Откроется страница входа в Grafana.

5. Чтобы войти в Grafana, введите ``admin`` в строке имя пользователя и строке пароль.

6. В правом верхнем углу щелкните значок справки.

   Появится информация о версии.

7. Чтобы просмотреть историю новых развертываний, выполните следующую команду:
   ~~~ Bash
   kubectl rollout history deployment grafana --namespace=my-grafana
   ~~~
   Для возвращения к любому другому варианту ``REVISION``, повторите описанные выше шаги и используйте правильный номер редакции в параметре ``--to-revision``.


### Удаление Grafana

Для удаления какого-либо из объектов развертывания Grafana, используйте ``kubectl delete command``.

1. Чтобы удалить полное развертывание Grafana, выполните следующую команду:
   ~~~ Bash
   kubectl delete -f grafana.yaml --namespace=my-grafana
   ~~~
   Эта команда удаляет объекты deployment, persistentvolumeclaim и service.

2. Чтобы удалить ``ConfigMap``, выполните следующую команду:
   ~~~ Bash
   kubectl delete configmap ge-config --namespace=my-grafana
   ~~~

